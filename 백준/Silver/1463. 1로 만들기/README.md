**********************
DP의 개념

https://hongjw1938.tistory.com/47


--------문제 푸는 방식---------





dp = 값을 메모 (기억)한다.

고정 관념 : dp 배열 안의 n 값은 (ex: dp[n] )은 
모든 숫자가 들어갈 수 있다.
counting만 들어가는 것이 아닌 주어진 수 n 그자체가 들어갈 수도 있다는 것을
의미한다!

dp[1]=0

dp[2]=2->1	| dp[2]=1
dp[3]=3->1	| dp[3]=1	
dp[4]=4->2->1	| dp[4]= 1+dp[i/2] (2) 
// 4->2 이후의 dp[2]의 과정이 이루어 지기 때문.
dp[5]=5->4->2->1 | dp[5] = 1+dp[i-1] (4)
// dp[4]처럼 이후 과정 반복이기 때문에 의미.
dp[6] = 6->3->1 or 6->2->1 | dp[6]=1+dp[i/2] or dp[6]= 1+ dp[i/3]
둘 중의 작은 값 choice

--> 
case 분류 
[1] i과 2와 3으로 모두 나누어 떨어지지 않는 경우
1을 빼주는 연산 횟수 (counting+1) + 직전의 연산 횟수의 최솟값

[2] i가 2로만 나누어 떨어지는 경우 
i/2로 만들어 주는 연산횟수 (counting +1) +직전의 숫자(i)의 /2 의 연산 횟수 와
1을 빼주는 연산 횟수 (counting+1) + 직전의 숫자의 /3의 연산 횟수의 최솟값


[3] i가 3으로만 나누어 떨어지는 경우

i/3으로 만들어주는 연산 횟수 (counting +1) + 직전의 숫자(i)의 /3의 연산 횟수


[4] i가 2와 3 둘다 나누어 떨어지는게 가능한 경우

[2]와 [3]의 경우에서의 최솟 값 
* 참고 * : [4] 같은 경우에는 최소가 6으로 시작하기에, 어떠한 경우든 직전에 있는
[2]와 [3]의 case가 존재하므로 
[2]와 같이 둘 중 하나 고르는 min을 한 번 더 수행할 필요가 없다.
* 참고 * : 왜 전의 dp에서 1을 더했는데 왜 추가로 1을 이번 연산에서도 더해주냐?
-> dp(i/2)로  가는 연산은 항상 필요하기에 이에 대한 연산 횟수 counting+1을 해주는
것이다.




지세한 내용은 아래 사이트를 참고하였다.

https://ssinee.tistory.com/entry/%EB%B0%B1%EC%A4%80-1463%EB%B2%88-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-CDP



************************


# [Silver III] 1로 만들기 - 1463 

[문제 링크](https://www.acmicpc.net/problem/1463) 

### 성능 요약

메모리: 5928 KB, 시간: 4 ms

### 분류

다이나믹 프로그래밍

### 문제 설명

<p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p>

<ol>
	<li>X가 3으로 나누어 떨어지면, 3으로 나눈다.</li>
	<li>X가 2로 나누어 떨어지면, 2로 나눈다.</li>
	<li>1을 뺀다.</li>
</ol>

<p>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</p>

### 입력 

 <p>첫째 줄에 1보다 크거나 같고, 10<sup>6</sup>보다 작거나 같은 정수 N이 주어진다.</p>

### 출력 

 <p>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.</p>

