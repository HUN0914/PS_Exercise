************

오답노트 [답지 봄..]


처음에 dfs,bfs 문제인줄 알고 접근했으나 안되는걸 알고 포기했고 결국엔 답지를 보고 푼 문제이다.

이 문제는 *그리디 알고리즘*으로 해결하는 문제였다.

-> 그래서, 푸는 방법으로는

끝나는 시간 순으로 오름차순 정렬을 하여(빨리 끝나는 순)

끝나는 시간과 다음 시작하는 시간을 비교했을 때, 다음 시작하는 시간이 더 크다면
counting을 해주고 그때의 시작 값을 다른 변수에 담아준 뒤,
다시 다음 차례에 나오는 처음 시작하는 시간과 비교하는 문제이다.

내가 답지를 보면서 
만약

1	4
4	9 (counting : 2)
와

1	4
5	7
7	8 (conuting :3)

이렇게 되면은 그렇게 풀면 안 되지 않나? 생각을 했지만, 애초에 저 논제 같은 경우에는 

4 9, 라는 전제가 5,7,8이 있다면 오름차순 정렬에 위배되기 때문에 존재할 수가 없다는 것을 곰곰히 답지를 곱씹어보며

알아냈다.

핵심 알고리즘

	int value = v[0].first;
	for (int i = 1; i < v.size(); i++)
	{
		if (v[i].second>= value)
		{
			count++;
			value = v[i].first;
		}

	}

 그리고, 어쨌던간 무조건 1번은 회의를 수행할 수 있기 때문에 cout또한 count+1로 해주었다.


*************


# [Silver I] 회의실 배정 - 1931 

[문제 링크](https://www.acmicpc.net/problem/1931) 

### 성능 요약

메모리: 3572 KB, 시간: 88 ms

### 분류

그리디 알고리즘, 정렬

### 문제 설명

<p>한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.</p>

### 입력 

 <p>첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 2<sup>31</sup>-1보다 작거나 같은 자연수 또는 0이다.</p>

### 출력 

 <p>첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.</p>

