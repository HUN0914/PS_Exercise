-----------------------
https://yabmoons.tistory.com/18

- DP문제에서 특정 날 수 제한 등이 있으면 뒤에서부터 계산하는 것이 정공법인것 같다.
- DP, 재귀함수 등은 일단 직관적으로 점화식을 세우면 풀리는 경우가 많은 것 같다.

1. i-3번째를 마시고 i-1,i번째를 마신다.

2. i-2번째를 마시고 i번째를 마신다.

3. i-1번째를 마시고 i번째를 마시지 않는다. -> 이게 중요했다. i번째를 마시지않고 i-1를 마시는 경우가 더 큰값을 가질수 있다. -> 여러 잔을 건너뛸수 있기 때문이다.

O	X	O	O	(arr[n]+arr[n-1]+dp[n-3])

O  	O	X	O	(arr[n]+dp[n-2})

O   	X	O	X	(dp[n-1]) 


위와 같이 Case를 분류해주면 다음과 같은 결과가 나온다,

즉슨,

		dp[i] = max(dp[i - 3] + arr[i - 1] + arr[i], max(dp[i - 1], dp[i - 2] + arr[i]));

임을 보일 수 있다.

+) 초기값 설정도 매우 중요한데 여기서, 처음 시작을 

	dp[1] = arr[1];
	dp[2] = dp[1]+arr[2];

  위와 같이 잡아주어야 한다. 

	for (int i = 3; i <= t; i++)
	{
		dp[i] = max(dp[i - 3] + arr[i - 1] + arr[i], max(dp[i - 1], dp[i - 2] + arr[i]));
	}

 i=4가 되면 안되는 이유 : i=4부터 시작을 한다면 dp[3]=0이 된다. (0이 아닌데도)

 그럼 dp[3]의 값이 max가 될 때 값이 제대로 출력되지 않는다.

 +) 추가로 dp[0]=0으로 *반드시* 설정해야 하는 이유 

 그렇게 하지 않으면 i=3부터의 반복문에서 i=3일 때 dp[3]에는 dp[0]+arr[1]+arr[2]의 값이 들어갈 수 있는데 만약 dp[0]의 값이 존재하게 된다면

' 연속으로 놓여 있는 3잔을 모두 마실 수는 없다. '

의 규칙을 위배하기 때문이다.
  

-----------------------

# [Silver I] 포도주 시식 - 2156 

[문제 링크](https://www.acmicpc.net/problem/2156) 

### 성능 요약

메모리: 2100 KB, 시간: 0 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2024년 2월 21일 14:38:29

### 문제 설명

<p>효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.</p>

<ol>
	<li>포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.</li>
	<li>연속으로 놓여 있는 3잔을 모두 마실 수는 없다.</li>
</ol>

<p>효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. </p>

<p>예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.</p>

### 입력 

 <p>첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.</p>

### 출력 

 <p>첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.</p>

