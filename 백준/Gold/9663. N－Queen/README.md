-----------------

cur은 열, i는 행을 나타낸다.

처음 0,0에 퀸을 놓았을 때부터 시작, 이때는 true일 때가 없으니(초기값) 바로 cur+1을 해줌.

cur=1 즉,0열이 아닌 1열로 왔을 때, 

1열에 있을 때의 모든 행을 추적하여 되는 case를 찾는다. 

안된다면 continue

이 모든 과정을 끝낸 후, 처음 스타트를 0,1를 잡은 후에 
[!!cur은 초깃값이 0으로 시작하기에 어떤 1번 큰 재귀를 돌면 다시 cur=0인 상태로 스타트이다.]

위와 같은 과정을 무한번 반복한다.

자세한건 바킹독 깃허브 참고.

**참고 )

어짜피 퀸을 놓는 순간 바로 다음 열로 넘어가서 놓을 수 있는 위치를 참고해야 하기에
isused에 행의 위치에 대한 정보는 담지 않았다.

+ 오른쪽 대각선은 항상 그 위치에서 x+y의 값이기에 i+cur, 
왼쪽 대각선의 위치는 y-x이지만, 배열이기에 음수를 담지 않기 위해서 y-x+n-1로 지정해준다.
(퀸은 대각, 위/아래 둘다 갈 수 있기 때문에 위와 같이 지정. 자세한건 또한 바킹독 유튜브 참고)
------------------


# [Gold IV] N-Queen - 9663 

[문제 링크](https://www.acmicpc.net/problem/9663) 

### 성능 요약

메모리: 2020 KB, 시간: 1676 ms

### 분류

백트래킹, 브루트포스 알고리즘

### 제출 일자

2024년 3월 5일 21:06:38

### 문제 설명

<p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</p>

<p>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N이 주어진다. (1 ≤ N < 15)</p>

### 출력 

 <p>첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.</p>

